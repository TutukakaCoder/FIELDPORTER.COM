{
  "name": "FIELDPORTER Chat Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "fieldporter-chat",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "https://fieldporter.com,http://localhost:3001"
        }
      },
      "id": "webhook-trigger",
      "name": "Chat Message Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "fieldporter-chat-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate incoming message data\nconst body = $input.first().json.body;\n\n// Validate required fields\nif (!body.message || !body.sessionId) {\n  throw new Error('Missing required fields: message and sessionId');\n}\n\n// Extract conversation history (last 5 messages for context)\nconst messages = body.conversationHistory || [];\nconst recentMessages = messages.slice(-5);\n\n// FIELDPORTER company context\nconst companyContext = `You are an AI assistant for FIELDPORTER, a premium AI Strategy & Business Automation Consultancy.\n\nCOMPANY OVERVIEW:\n- Company: FIELDPORTER - AI Strategy & Business Automation Consultancy\n- Services: AI Strategy Development, Business Process Automation, VC Portfolio Optimization\n- Approach: \"We build what we recommend\" - proven through our own operations\n- Target: Enterprise clients seeking AI transformation and automation\n\nKEY DIFFERENTIATORS:\n- Hands-on implementation experience, not just consulting\n- Proven track record with our own AI-powered operations\n- Focus on measurable ROI and business outcomes\n- Expertise in both strategy and technical execution\n\nGOAL: Guide users toward booking a consultation for detailed discussion of their AI strategy needs.\n\nRESPONSE GUIDELINES:\n- Keep responses concise (under 200 words)\n- Focus on business value and outcomes\n- Ask qualifying questions about their business challenges\n- Suggest consultation when appropriate\n- Maintain professional, consultative tone\n- Avoid technical jargon unless specifically asked`;\n\n// Build conversation context\nlet conversationContext = companyContext + \"\\n\\nCONVERSATION HISTORY:\\n\";\nrecentMessages.forEach(msg => {\n  conversationContext += `${msg.role}: ${msg.content}\\n`;\n});\nconversationContext += `user: ${body.message}\\nassistant:`;\n\n// Prepare data for next node\nreturn {\n  message: body.message,\n  sessionId: body.sessionId,\n  userEmail: body.userEmail || null,\n  conversationHistory: recentMessages,\n  conversationContext: conversationContext,\n  timestamp: new Date().toISOString()\n};"
      },
      "id": "context-preparation",
      "name": "Context Preparation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.deepseek.com/chat/completions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $credentials.deepseekApi.apiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "deepseek-chat"
            },
            {
              "name": "messages",
              "value": "=[{\"role\": \"system\", \"content\": \"{{ $json.conversationContext }}\"}, {\"role\": \"user\", \"content\": \"{{ $json.message }}\"}]"
            },
            {
              "name": "max_tokens",
              "value": 200
            },
            {
              "name": "temperature",
              "value": 0.7
            },
            {
              "name": "stream",
              "value": false
            }
          ]
        },
        "options": {
          "timeout": 8000,
          "retry": {
            "enabled": true,
            "maxRetries": 2
          }
        }
      },
      "id": "deepseek-api-call",
      "name": "DeepSeek API Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [680, 300],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Handle DeepSeek API response or error\nconst input = $input.first().json;\n\nlet aiResponse = \"I apologize, but I'm experiencing technical difficulties. Please try again in a moment, or feel free to contact us directly for immediate assistance with your AI strategy needs.\";\n\n// Check if we have a successful API response\nif (input.choices && input.choices[0] && input.choices[0].message) {\n  aiResponse = input.choices[0].message.content.trim();\n} else if (input.error) {\n  console.log('DeepSeek API Error:', input.error);\n  // Use fallback response\n}\n\n// Clean and format the response\naiResponse = aiResponse\n  .replace(/\\n\\s*\\n/g, '\\n\\n') // Clean up extra newlines\n  .trim();\n\n// Ensure response isn't too long\nif (aiResponse.length > 500) {\n  aiResponse = aiResponse.substring(0, 497) + '...';\n}\n\n// Get original message data\nconst originalData = $('Context Preparation').first().json;\n\nreturn {\n  sessionId: originalData.sessionId,\n  message: originalData.message,\n  response: aiResponse,\n  userEmail: originalData.userEmail,\n  conversationHistory: originalData.conversationHistory,\n  timestamp: originalData.timestamp,\n  apiSuccess: !!input.choices\n};"
      },
      "id": "response-processing",
      "name": "Response Processing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "// Simple lead scoring logic\nconst data = $input.first().json;\nconst message = data.message.toLowerCase();\nconst hasEmail = !!data.userEmail;\nconst conversationLength = data.conversationHistory.length + 1;\n\nlet leadScore = 0;\n\n// Scoring criteria\nif (message.includes('budget') || message.includes('pricing') || message.includes('cost')) {\n  leadScore += 2;\n}\n\nif (message.includes('timeline') || message.includes('when') || message.includes('schedule')) {\n  leadScore += 2;\n}\n\nif (message.includes('case study') || message.includes('example') || message.includes('portfolio')) {\n  leadScore += 1;\n}\n\nif (message.includes('consultation') || message.includes('meeting') || message.includes('call')) {\n  leadScore += 5;\n}\n\nif (hasEmail) {\n  leadScore += 3;\n}\n\n// Multiple messages indicate engagement\nif (conversationLength > 3) {\n  leadScore += Math.min(conversationLength - 3, 3); // Max 3 bonus points\n}\n\n// Business-related keywords\nconst businessKeywords = ['strategy', 'ai', 'automation', 'business', 'implementation', 'roi', 'efficiency', 'optimization'];\nconst hasBusinessKeywords = businessKeywords.some(keyword => message.includes(keyword));\nif (hasBusinessKeywords) {\n  leadScore += 1;\n}\n\n// Cap at 10\nleadScore = Math.min(leadScore, 10);\n\n// Determine lead quality\nlet leadQuality = 'low';\nif (leadScore >= 8) leadQuality = 'high';\nelse if (leadScore >= 5) leadQuality = 'medium';\n\nreturn {\n  ...data,\n  leadScore: leadScore,\n  leadQuality: leadQuality,\n  scoringFactors: {\n    hasEmail: hasEmail,\n    conversationLength: conversationLength,\n    hasBusinessKeywords: hasBusinessKeywords,\n    mentionsBudget: message.includes('budget') || message.includes('pricing'),\n    mentionsTimeline: message.includes('timeline') || message.includes('when'),\n    requestsConsultation: message.includes('consultation') || message.includes('meeting')\n  }\n};"
      },
      "id": "lead-scoring",
      "name": "Lead Scoring Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.fieldporter.com/webhook/conversation-log",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-API-Key",
              "value": "{{ $credentials.fieldporterApi.apiKey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "sessionId",
              "value": "={{ $json.sessionId }}"
            },
            {
              "name": "userMessage",
              "value": "={{ $json.message }}"
            },
            {
              "name": "aiResponse",
              "value": "={{ $json.response }}"
            },
            {
              "name": "leadScore",
              "value": "={{ $json.leadScore }}"
            },
            {
              "name": "leadQuality",
              "value": "={{ $json.leadQuality }}"
            },
            {
              "name": "userEmail",
              "value": "={{ $json.userEmail }}"
            },
            {
              "name": "timestamp",
              "value": "={{ $json.timestamp }}"
            },
            {
              "name": "apiSuccess",
              "value": "={{ $json.apiSuccess }}"
            },
            {
              "name": "scoringFactors",
              "value": "={{ JSON.stringify($json.scoringFactors) }}"
            }
          ]
        },
        "options": {
          "timeout": 3000
        }
      },
      "id": "conversation-logging",
      "name": "Log Conversation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1340, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"response\": \"{{ $json.response }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"leadScore\": {{ $json.leadScore }},\n  \"leadQuality\": \"{{ $json.leadQuality }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\"\n}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "webhook-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"Service temporarily unavailable\",\n  \"response\": \"I apologize, but I'm experiencing technical difficulties. Please try again in a moment, or contact us directly for immediate assistance.\",\n  \"sessionId\": \"{{ $('Context Preparation').first().json.sessionId }}\",\n  \"timestamp\": \"{{ new Date().toISOString() }}\"\n}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [900, 500]
    }
  ],
  "connections": {
    "Chat Message Webhook": {
      "main": [
        [
          {
            "node": "Context Preparation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Preparation": {
      "main": [
        [
          {
            "node": "DeepSeek API Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DeepSeek API Call": {
      "main": [
        [
          {
            "node": "Response Processing",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response Processing": {
      "main": [
        [
          {
            "node": "Lead Scoring Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lead Scoring Logic": {
      "main": [
        [
          {
            "node": "Log Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Conversation": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "fieldporter-chat-workflow",
  "tags": [
    {
      "createdAt": "2025-01-27T10:00:00.000Z",
      "updatedAt": "2025-01-27T10:00:00.000Z",
      "id": "fieldporter",
      "name": "fieldporter"
    }
  ]
}
